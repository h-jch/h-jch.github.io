<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>最小生成树 | Kei's Blog</title><meta name=keywords content="数据结构"><meta name=description content="基本概念 最小生成树 是一棵树 无回路，向生成树中任加一条边都一定构成回路 |V|个顶点一定有|V|-1条边 是生成树 包含全部顶点 |V|-1条边都在图"><meta name=author content="kei"><link rel=canonical href=https://h-jch.github.io/posts/code/minimum-spanning-tree/><link crossorigin=anonymous href=/assets/css/stylesheet.678b5c47efa744d2e0dd0d61101075e6aecdc9a0631e7ad8538f4ec0cca79273.css integrity="sha256-Z4tcR++nRNLg3Q1hEBB15q7NyaBjHnrYU49OwMynknM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://h-jch.github.io/images/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://h-jch.github.io/images/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://h-jch.github.io/images/avatar.png><link rel=apple-touch-icon href=https://h-jch.github.io/images/avatar.png><link rel=mask-icon href=https://h-jch.github.io/images/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="最小生成树"><meta property="og:description" content="基本概念 最小生成树 是一棵树 无回路，向生成树中任加一条边都一定构成回路 |V|个顶点一定有|V|-1条边 是生成树 包含全部顶点 |V|-1条边都在图"><meta property="og:type" content="article"><meta property="og:url" content="https://h-jch.github.io/posts/code/minimum-spanning-tree/"><meta property="og:image" content="https://h-jch.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-07-30T16:37:00+08:00"><meta property="article:modified_time" content="2019-07-30T16:37:00+08:00"><meta property="og:site_name" content="Kei's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://h-jch.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="最小生成树"><meta name=twitter:description content="基本概念 最小生成树 是一棵树 无回路，向生成树中任加一条边都一定构成回路 |V|个顶点一定有|V|-1条边 是生成树 包含全部顶点 |V|-1条边都在图"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://h-jch.github.io/posts/"},{"@type":"ListItem","position":3,"name":"最小生成树","item":"https://h-jch.github.io/posts/code/minimum-spanning-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"最小生成树","name":"最小生成树","description":"基本概念 最小生成树 是一棵树 无回路，向生成树中任加一条边都一定构成回路 |V|个顶点一定有|V|-1条边 是生成树 包含全部顶点 |V|-1条边都在图","keywords":["数据结构"],"articleBody":"基本概念 最小生成树\n是一棵树 无回路，向生成树中任加一条边都一定构成回路 |V|个顶点一定有|V|-1条边 是生成树 包含全部顶点 |V|-1条边都在图里 边的权重最小 贪心算法 对于如何最小生成树的算法，我们使用贪心算法。\n什么是“贪”：每一步都要好的 什么是“好”：权重最小的边 需要约束 只能用图里有的边 只能正好用掉|V|-1条边 不能有回路 Prim算法 类似Dijkstra算法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 Vertex FindMinDist(MGraph Graph, WeightType dist[]){ //返回未被收录顶点中dist最小者 Vertex MinV,V; WeightType MinDist=INFINITY; for(V=0;V\u003cGraph-\u003eNv;V++){ //对于图中每个顶点V if(dist[V]!=0\u0026\u0026dist[V]\u003cMinDist){ //若V未被收录且dist[V]更小 MinDist=dist[V]; //更新最小距离 MinV=V; //更新对应顶点 } } if(MinDist\u003cINFINITY) return MinV; else return false; } int Prim(MGraph Graph, LGraph MST){ //将最小生成树保存为邻接表存储的图MST，返回最小权重和 WeightType dist[MaxVertexNum],TotalWeight; Vertex parent[MaxVertexNum],V,W; int VCount; Edge E; for(V=0;V\u003cGraph-\u003eNv;V++){ //初始化，默认初始顶点下标为0 dist[V]=Graph-\u003eG[0][V]; parent[V]=0; } TotalWeight=0; VCount=0; MST=CreateGraph(Graph-\u003eNv); //创建包含所有顶点但没有边的邻接表存储的图 E=(Edge)malloc(sizeof(struct ENode)); //建立空的边结点 dist[0]=0; VCount++; parent[0]=-1; while(1){ V=FindMinDist(Graph, dist); //找到未被收录顶点中dist最小者 if(V==ERROR) break; E-\u003eV1=parent[V]; //将V及相应的边收录进MST E-\u003eV2=V; E-\u003eWeight=dist[V]; InsertEdge(MST,E); TotalWeight+=dist[V]; dist[V]=0; VCount++; for(W=0;W\u003cGraph-\u003eNv;W++) if(dist[W]!=0\u0026\u0026Graph-\u003eG[V][W]\u003cINFINITY){ //若W未被收录且W是V的邻接点 if(Graph-\u003eG[V][W]\u003cdist[W]){ //收录进V使得dist[W]变小 dist[W]=Graph-\u003eG[V][W]; //更新dist[W] parent[W]=V; //更新树 } }\t} if(VCount\u003cGraph-\u003eNv) //MST中的顶点不到|V|个 TotalWeight=ERROR; return TotalWeight; } 对于稠密图，时间复杂度T=O(|V|^2)\nKruskal算法 Kruskal算法是将森林合并成树。 伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void Kruskal(Graph G){ MST={ }; while(MST中不到|V|-1条边 \u0026\u0026 E中还有边){ 从E中取一条权重最小的边E(V,W); //最小堆 将E(V,W)从E中删除; if(E(V,W)不在MST中构成回路) //并查集 将E(V,W)加入MST; else 彻底无视E(V,W); } if(MST中不到|V|-1条边) ERROR(\"生成树不存在\"); } C语言代码如下，摘自浙大陈越奶奶数据结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 /* 邻接表存储 - Kruskal最小生成树算法 */ /*-------------------- 顶点并查集定义 --------------------*/ typedef Vertex ElementType; /* 默认元素可以用非负整数表示 */ typedef Vertex SetName; /* 默认用根结点的下标作为集合名称 */ typedef ElementType SetType[MaxVertexNum]; /* 假设集合元素下标从0开始 */ void InitializeVSet( SetType S, int N ) { /* 初始化并查集 */ ElementType X; for ( X=0; X\u003cN; X++ ) S[X] = -1; } void Union( SetType S, SetName Root1, SetName Root2 ) { /* 这里默认Root1和Root2是不同集合的根结点 */ /* 保证小集合并入大集合 */ if ( S[Root2] \u003c S[Root1] ) { /* 如果集合2比较大 */ S[Root2] += S[Root1]; /* 集合1并入集合2 */ S[Root1] = Root2; } else { /* 如果集合1比较大 */ S[Root1] += S[Root2]; /* 集合2并入集合1 */ S[Root2] = Root1; } } SetName Find( SetType S, ElementType X ) { /* 默认集合元素全部初始化为-1 */ if ( S[X] \u003c 0 ) /* 找到集合的根 */ return X; else return S[X] = Find( S, S[X] ); /* 路径压缩 */ } bool CheckCycle( SetType VSet, Vertex V1, Vertex V2 ) { /* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 */ Vertex Root1, Root2; Root1 = Find( VSet, V1 ); /* 得到V1所属的连通集名称 */ Root2 = Find( VSet, V2 ); /* 得到V2所属的连通集名称 */ if( Root1==Root2 ) /* 若V1和V2已经连通，则该边不能要 */ return false; else { /* 否则该边可以被收集，同时将V1和V2并入同一连通集 */ Union( VSet, Root1, Root2 ); return true; } } /*-------------------- 并查集定义结束 --------------------*/ /*-------------------- 边的最小堆定义 --------------------*/ void PercDown( Edge ESet, int p, int N ) { /* 改编代码4.24的PercDown( MaxHeap H, int p ) */ /* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 */ int Parent, Child; struct ENode X; X = ESet[p]; /* 取出根结点存放的值 */ for( Parent=p; (Parent*2+1)\u003cN; Parent=Child ) { Child = Parent * 2 + 1; if( (Child!=N-1) \u0026\u0026 (ESet[Child].Weight\u003eESet[Child+1].Weight) ) Child++; /* Child指向左右子结点的较小者 */ if( X.Weight \u003c= ESet[Child].Weight ) break; /* 找到了合适位置 */ else /* 下滤X */ ESet[Parent] = ESet[Child]; } ESet[Parent] = X; } void InitializeESet( LGraph Graph, Edge ESet ) { /* 将图的边存入数组ESet，并且初始化为最小堆 */ Vertex V; PtrToAdjVNode W; int ECount; /* 将图的边存入数组ESet */ ECount = 0; for ( V=0; V\u003cGraph-\u003eNv; V++ ) for ( W=Graph-\u003eG[V].FirstEdge; W; W=W-\u003eNext ) if ( V \u003c W-\u003eAdjV ) { /* 避免重复录入无向图的边，只收V1","wordCount":"2127","inLanguage":"en","datePublished":"2019-07-30T16:37:00+08:00","dateModified":"2019-07-30T16:37:00+08:00","author":[{"@type":"Person","name":"kei"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://h-jch.github.io/posts/code/minimum-spanning-tree/"},"publisher":{"@type":"Organization","name":"Kei's Blog","logo":{"@type":"ImageObject","url":"https://h-jch.github.io/images/avatar.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://h-jch.github.io accesskey=h title="Kei's Blog (Alt + H)"><img src=https://h-jch.github.io/images/avatar.png alt aria-label=logo height=35>Kei's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://h-jch.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://h-jch.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://h-jch.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://h-jch.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>最小生成树</h1><div class=post-meta><span title='2019-07-30 16:37:00 +0800 CST'>2019-07-30</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;2127 words&nbsp;·&nbsp;kei</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=基本概念>基本概念</a></li><li><a href=#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95 aria-label=贪心算法>贪心算法</a></li><li><a href=#prim%e7%ae%97%e6%b3%95 aria-label=Prim算法>Prim算法</a></li><li><a href=#kruskal%e7%ae%97%e6%b3%95 aria-label=Kruskal算法>Kruskal算法</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=基本概念>基本概念<a hidden class=anchor aria-hidden=true href=#基本概念>#</a></h3><p>最小生成树</p><ul><li>是一棵树<ul><li>无回路，向生成树中任加一条边都一定构成回路</li><li>|V|个顶点一定有|V|-1条边</li></ul></li><li>是生成树<ul><li>包含全部顶点</li><li>|V|-1条边都在图里</li></ul></li><li>边的权重最小</li></ul><h3 id=贪心算法>贪心算法<a hidden class=anchor aria-hidden=true href=#贪心算法>#</a></h3><p>对于如何最小生成树的算法，我们使用贪心算法。</p><ul><li>什么是“贪”：每一步都要好的</li><li>什么是“好”：权重最小的边</li><li>需要约束<ul><li>只能用图里有的边</li><li>只能正好用掉|V|-1条边</li><li>不能有回路</li></ul></li></ul><h3 id=prim算法>Prim算法<a hidden class=anchor aria-hidden=true href=#prim算法>#</a></h3><p>类似Dijkstra算法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>Vertex</span> <span class=nf>FindMinDist</span><span class=p>(</span><span class=n>MGraph</span> <span class=n>Graph</span><span class=p>,</span> <span class=n>WeightType</span> <span class=n>dist</span><span class=p>[]){</span>    <span class=c1>//返回未被收录顶点中dist最小者
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Vertex</span> <span class=n>MinV</span><span class=p>,</span><span class=n>V</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>WeightType</span> <span class=n>MinDist</span><span class=o>=</span><span class=n>INFINITY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>V</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>V</span><span class=o>&lt;</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=p>;</span><span class=n>V</span><span class=o>++</span><span class=p>){</span>   <span class=c1>//对于图中每个顶点V
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=n>dist</span><span class=p>[</span><span class=n>V</span><span class=p>]</span><span class=o>!=</span><span class=mi>0</span><span class=o>&amp;&amp;</span><span class=n>dist</span><span class=p>[</span><span class=n>V</span><span class=p>]</span><span class=o>&lt;</span><span class=n>MinDist</span><span class=p>){</span>    <span class=c1>//若V未被收录且dist[V]更小
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>MinDist</span><span class=o>=</span><span class=n>dist</span><span class=p>[</span><span class=n>V</span><span class=p>];</span>    <span class=c1>//更新最小距离
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>MinV</span><span class=o>=</span><span class=n>V</span><span class=p>;</span>     <span class=c1>//更新对应顶点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>MinDist</span><span class=o>&lt;</span><span class=n>INFINITY</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>MinV</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Prim</span><span class=p>(</span><span class=n>MGraph</span> <span class=n>Graph</span><span class=p>,</span> <span class=n>LGraph</span> <span class=n>MST</span><span class=p>){</span>     <span class=c1>//将最小生成树保存为邻接表存储的图MST，返回最小权重和
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>WeightType</span> <span class=n>dist</span><span class=p>[</span><span class=n>MaxVertexNum</span><span class=p>],</span><span class=n>TotalWeight</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Vertex</span> <span class=n>parent</span><span class=p>[</span><span class=n>MaxVertexNum</span><span class=p>],</span><span class=n>V</span><span class=p>,</span><span class=n>W</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>VCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Edge</span> <span class=n>E</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>V</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>V</span><span class=o>&lt;</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=p>;</span><span class=n>V</span><span class=o>++</span><span class=p>){</span>   <span class=c1>//初始化，默认初始顶点下标为0
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>dist</span><span class=p>[</span><span class=n>V</span><span class=p>]</span><span class=o>=</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>V</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>parent</span><span class=p>[</span><span class=n>V</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>TotalWeight</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>VCount</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>MST</span><span class=o>=</span><span class=nf>CreateGraph</span><span class=p>(</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=p>);</span>     <span class=c1>//创建包含所有顶点但没有边的邻接表存储的图
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>E</span><span class=o>=</span><span class=p>(</span><span class=n>Edge</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>ENode</span><span class=p>));</span>   <span class=c1>//建立空的边结点
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>dist</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>VCount</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>parent</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>=-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>V</span><span class=o>=</span><span class=nf>FindMinDist</span><span class=p>(</span><span class=n>Graph</span><span class=p>,</span> <span class=n>dist</span><span class=p>);</span>     <span class=c1>//找到未被收录顶点中dist最小者
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=n>V</span><span class=o>==</span><span class=n>ERROR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>E</span><span class=o>-&gt;</span><span class=n>V1</span><span class=o>=</span><span class=n>parent</span><span class=p>[</span><span class=n>V</span><span class=p>];</span>    <span class=c1>//将V及相应的边&lt;parent[V],V&gt;收录进MST
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>E</span><span class=o>-&gt;</span><span class=n>V2</span><span class=o>=</span><span class=n>V</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>E</span><span class=o>-&gt;</span><span class=n>Weight</span><span class=o>=</span><span class=n>dist</span><span class=p>[</span><span class=n>V</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=nf>InsertEdge</span><span class=p>(</span><span class=n>MST</span><span class=p>,</span><span class=n>E</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>TotalWeight</span><span class=o>+=</span><span class=n>dist</span><span class=p>[</span><span class=n>V</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>dist</span><span class=p>[</span><span class=n>V</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>VCount</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=n>W</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>W</span><span class=o>&lt;</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=p>;</span><span class=n>W</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>dist</span><span class=p>[</span><span class=n>W</span><span class=p>]</span><span class=o>!=</span><span class=mi>0</span><span class=o>&amp;&amp;</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>V</span><span class=p>][</span><span class=n>W</span><span class=p>]</span><span class=o>&lt;</span><span class=n>INFINITY</span><span class=p>){</span>    <span class=c1>//若W未被收录且W是V的邻接点
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span><span class=p>(</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>V</span><span class=p>][</span><span class=n>W</span><span class=p>]</span><span class=o>&lt;</span><span class=n>dist</span><span class=p>[</span><span class=n>W</span><span class=p>]){</span>     <span class=c1>//收录进V使得dist[W]变小
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>dist</span><span class=p>[</span><span class=n>W</span><span class=p>]</span><span class=o>=</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>V</span><span class=p>][</span><span class=n>W</span><span class=p>];</span>     <span class=c1>//更新dist[W]
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>parent</span><span class=p>[</span><span class=n>W</span><span class=p>]</span><span class=o>=</span><span class=n>V</span><span class=p>;</span>    <span class=c1>//更新树
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>	
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>VCount</span><span class=o>&lt;</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=p>)</span>    <span class=c1>//MST中的顶点不到|V|个
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>TotalWeight</span><span class=o>=</span><span class=n>ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>TotalWeight</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>对于稠密图，时间复杂度T=O(|V|^2)</p><h3 id=kruskal算法>Kruskal算法<a hidden class=anchor aria-hidden=true href=#kruskal算法>#</a></h3><p>Kruskal算法是将森林合并成树。
伪代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Kruskal</span><span class=p>(</span><span class=n>Graph</span> <span class=n>G</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>MST</span><span class=o>=</span><span class=p>{</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>MST中不到</span><span class=o>|</span><span class=n>V</span><span class=o>|-</span><span class=mi>1</span><span class=err>条边</span> <span class=o>&amp;&amp;</span> <span class=n>E中还有边</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=err>从</span><span class=n>E中取一条权重最小的边E</span><span class=p>(</span><span class=n>V</span><span class=p>,</span><span class=n>W</span><span class=p>);</span>      <span class=c1>//最小堆
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=err>将</span><span class=n>E</span><span class=p>(</span><span class=n>V</span><span class=p>,</span><span class=n>W</span><span class=p>)</span><span class=err>从</span><span class=n>E中删除</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=nf>E</span><span class=p>(</span><span class=n>V</span><span class=p>,</span><span class=n>W</span><span class=p>)</span><span class=err>不在</span><span class=n>MST中构成回路</span><span class=p>)</span>     <span class=c1>//并查集
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=err>将</span><span class=n>E</span><span class=p>(</span><span class=n>V</span><span class=p>,</span><span class=n>W</span><span class=p>)</span><span class=err>加入</span><span class=n>MST</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=err>彻底无视</span><span class=n>E</span><span class=p>(</span><span class=n>V</span><span class=p>,</span><span class=n>W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>MST中不到</span><span class=o>|</span><span class=n>V</span><span class=o>|-</span><span class=mi>1</span><span class=err>条边</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>ERROR</span><span class=p>(</span><span class=s>&#34;生成树不存在&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>C语言代码如下，摘自浙大陈越奶奶数据结构：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* 邻接表存储 - Kruskal最小生成树算法 */</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=cm>/*-------------------- 顶点并查集定义 --------------------*/</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>Vertex</span> <span class=n>ElementType</span><span class=p>;</span> <span class=cm>/* 默认元素可以用非负整数表示 */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>Vertex</span> <span class=n>SetName</span><span class=p>;</span>     <span class=cm>/* 默认用根结点的下标作为集合名称 */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>ElementType</span> <span class=n>SetType</span><span class=p>[</span><span class=n>MaxVertexNum</span><span class=p>];</span> <span class=cm>/* 假设集合元素下标从0开始 */</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>InitializeVSet</span><span class=p>(</span> <span class=n>SetType</span> <span class=n>S</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> <span class=cm>/* 初始化并查集 */</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span> <span class=n>X</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>X</span><span class=o>&lt;</span><span class=n>N</span><span class=p>;</span> <span class=n>X</span><span class=o>++</span> <span class=p>)</span> <span class=n>S</span><span class=p>[</span><span class=n>X</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Union</span><span class=p>(</span> <span class=n>SetType</span> <span class=n>S</span><span class=p>,</span> <span class=n>SetName</span> <span class=n>Root1</span><span class=p>,</span> <span class=n>SetName</span> <span class=n>Root2</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> <span class=cm>/* 这里默认Root1和Root2是不同集合的根结点 */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 保证小集合并入大集合 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span> <span class=n>S</span><span class=p>[</span><span class=n>Root2</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>S</span><span class=p>[</span><span class=n>Root1</span><span class=p>]</span> <span class=p>)</span> <span class=p>{</span> <span class=cm>/* 如果集合2比较大 */</span>
</span></span><span class=line><span class=cl>        <span class=n>S</span><span class=p>[</span><span class=n>Root2</span><span class=p>]</span> <span class=o>+=</span> <span class=n>S</span><span class=p>[</span><span class=n>Root1</span><span class=p>];</span>     <span class=cm>/* 集合1并入集合2  */</span>
</span></span><span class=line><span class=cl>        <span class=n>S</span><span class=p>[</span><span class=n>Root1</span><span class=p>]</span> <span class=o>=</span> <span class=n>Root2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>                         <span class=cm>/* 如果集合1比较大 */</span>
</span></span><span class=line><span class=cl>        <span class=n>S</span><span class=p>[</span><span class=n>Root1</span><span class=p>]</span> <span class=o>+=</span> <span class=n>S</span><span class=p>[</span><span class=n>Root2</span><span class=p>];</span>     <span class=cm>/* 集合2并入集合1  */</span>
</span></span><span class=line><span class=cl>        <span class=n>S</span><span class=p>[</span><span class=n>Root2</span><span class=p>]</span> <span class=o>=</span> <span class=n>Root1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=n>SetName</span> <span class=nf>Find</span><span class=p>(</span> <span class=n>SetType</span> <span class=n>S</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> <span class=cm>/* 默认集合元素全部初始化为-1 */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span> <span class=n>S</span><span class=p>[</span><span class=n>X</span><span class=p>]</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=p>)</span> <span class=cm>/* 找到集合的根 */</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>S</span><span class=p>[</span><span class=n>X</span><span class=p>]</span> <span class=o>=</span> <span class=nf>Find</span><span class=p>(</span> <span class=n>S</span><span class=p>,</span> <span class=n>S</span><span class=p>[</span><span class=n>X</span><span class=p>]</span> <span class=p>);</span> <span class=cm>/* 路径压缩 */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>CheckCycle</span><span class=p>(</span> <span class=n>SetType</span> <span class=n>VSet</span><span class=p>,</span> <span class=n>Vertex</span> <span class=n>V1</span><span class=p>,</span> <span class=n>Vertex</span> <span class=n>V2</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> <span class=cm>/* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 */</span>
</span></span><span class=line><span class=cl>    <span class=n>Vertex</span> <span class=n>Root1</span><span class=p>,</span> <span class=n>Root2</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>Root1</span> <span class=o>=</span> <span class=nf>Find</span><span class=p>(</span> <span class=n>VSet</span><span class=p>,</span> <span class=n>V1</span> <span class=p>);</span> <span class=cm>/* 得到V1所属的连通集名称 */</span>
</span></span><span class=line><span class=cl>    <span class=n>Root2</span> <span class=o>=</span> <span class=nf>Find</span><span class=p>(</span> <span class=n>VSet</span><span class=p>,</span> <span class=n>V2</span> <span class=p>);</span> <span class=cm>/* 得到V2所属的连通集名称 */</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span> <span class=n>Root1</span><span class=o>==</span><span class=n>Root2</span> <span class=p>)</span> <span class=cm>/* 若V1和V2已经连通，则该边不能要 */</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span> <span class=cm>/* 否则该边可以被收集，同时将V1和V2并入同一连通集 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>Union</span><span class=p>(</span> <span class=n>VSet</span><span class=p>,</span> <span class=n>Root1</span><span class=p>,</span> <span class=n>Root2</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*-------------------- 并查集定义结束 --------------------*/</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=cm>/*-------------------- 边的最小堆定义 --------------------*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>PercDown</span><span class=p>(</span> <span class=n>Edge</span> <span class=n>ESet</span><span class=p>,</span> <span class=kt>int</span> <span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> <span class=cm>/* 改编代码4.24的PercDown( MaxHeap H, int p )    */</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Parent</span><span class=p>,</span> <span class=n>Child</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>ENode</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>X</span> <span class=o>=</span> <span class=n>ESet</span><span class=p>[</span><span class=n>p</span><span class=p>];</span> <span class=cm>/* 取出根结点存放的值 */</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span> <span class=n>Parent</span><span class=o>=</span><span class=n>p</span><span class=p>;</span> <span class=p>(</span><span class=n>Parent</span><span class=o>*</span><span class=mi>2</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>&lt;</span><span class=n>N</span><span class=p>;</span> <span class=n>Parent</span><span class=o>=</span><span class=n>Child</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Child</span> <span class=o>=</span> <span class=n>Parent</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span> <span class=p>(</span><span class=n>Child</span><span class=o>!=</span><span class=n>N</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>ESet</span><span class=p>[</span><span class=n>Child</span><span class=p>].</span><span class=n>Weight</span><span class=o>&gt;</span><span class=n>ESet</span><span class=p>[</span><span class=n>Child</span><span class=o>+</span><span class=mi>1</span><span class=p>].</span><span class=n>Weight</span><span class=p>)</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>Child</span><span class=o>++</span><span class=p>;</span>  <span class=cm>/* Child指向左右子结点的较小者 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span> <span class=n>X</span><span class=p>.</span><span class=n>Weight</span> <span class=o>&lt;=</span> <span class=n>ESet</span><span class=p>[</span><span class=n>Child</span><span class=p>].</span><span class=n>Weight</span> <span class=p>)</span> <span class=k>break</span><span class=p>;</span> <span class=cm>/* 找到了合适位置 */</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>  <span class=cm>/* 下滤X */</span>
</span></span><span class=line><span class=cl>            <span class=n>ESet</span><span class=p>[</span><span class=n>Parent</span><span class=p>]</span> <span class=o>=</span> <span class=n>ESet</span><span class=p>[</span><span class=n>Child</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>ESet</span><span class=p>[</span><span class=n>Parent</span><span class=p>]</span> <span class=o>=</span> <span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>InitializeESet</span><span class=p>(</span> <span class=n>LGraph</span> <span class=n>Graph</span><span class=p>,</span> <span class=n>Edge</span> <span class=n>ESet</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> <span class=cm>/* 将图的边存入数组ESet，并且初始化为最小堆 */</span>
</span></span><span class=line><span class=cl>    <span class=n>Vertex</span> <span class=n>V</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PtrToAdjVNode</span> <span class=n>W</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ECount</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=cm>/* 将图的边存入数组ESet */</span>
</span></span><span class=line><span class=cl>    <span class=n>ECount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span> <span class=n>V</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>V</span><span class=o>&lt;</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=p>;</span> <span class=n>V</span><span class=o>++</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span> <span class=n>W</span><span class=o>=</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>V</span><span class=p>].</span><span class=n>FirstEdge</span><span class=p>;</span> <span class=n>W</span><span class=p>;</span> <span class=n>W</span><span class=o>=</span><span class=n>W</span><span class=o>-&gt;</span><span class=n>Next</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span> <span class=n>V</span> <span class=o>&lt;</span> <span class=n>W</span><span class=o>-&gt;</span><span class=n>AdjV</span> <span class=p>)</span> <span class=p>{</span> <span class=cm>/* 避免重复录入无向图的边，只收V1&lt;V2的边 */</span>
</span></span><span class=line><span class=cl>                <span class=n>ESet</span><span class=p>[</span><span class=n>ECount</span><span class=p>].</span><span class=n>V1</span> <span class=o>=</span> <span class=n>V</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>ESet</span><span class=p>[</span><span class=n>ECount</span><span class=p>].</span><span class=n>V2</span> <span class=o>=</span> <span class=n>W</span><span class=o>-&gt;</span><span class=n>AdjV</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>ESet</span><span class=p>[</span><span class=n>ECount</span><span class=o>++</span><span class=p>].</span><span class=n>Weight</span> <span class=o>=</span> <span class=n>W</span><span class=o>-&gt;</span><span class=n>Weight</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 初始化为最小堆 */</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span> <span class=n>ECount</span><span class=o>=</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Ne</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span> <span class=n>ECount</span><span class=o>&gt;=</span><span class=mi>0</span><span class=p>;</span> <span class=n>ECount</span><span class=o>--</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>PercDown</span><span class=p>(</span> <span class=n>ESet</span><span class=p>,</span> <span class=n>ECount</span><span class=p>,</span> <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Ne</span> <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>GetEdge</span><span class=p>(</span> <span class=n>Edge</span> <span class=n>ESet</span><span class=p>,</span> <span class=kt>int</span> <span class=n>CurrentSize</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> <span class=cm>/* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 */</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=cm>/* 将最小边与当前堆的最后一个位置的边交换 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>Swap</span><span class=p>(</span> <span class=o>&amp;</span><span class=n>ESet</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>ESet</span><span class=p>[</span><span class=n>CurrentSize</span><span class=o>-</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 将剩下的边继续调整成最小堆 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>PercDown</span><span class=p>(</span> <span class=n>ESet</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>CurrentSize</span><span class=o>-</span><span class=mi>1</span> <span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>CurrentSize</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=cm>/* 返回最小边所在位置 */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*-------------------- 最小堆定义结束 --------------------*/</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Kruskal</span><span class=p>(</span> <span class=n>LGraph</span> <span class=n>Graph</span><span class=p>,</span> <span class=n>LGraph</span> <span class=n>MST</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> <span class=cm>/* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 */</span>
</span></span><span class=line><span class=cl>    <span class=n>WeightType</span> <span class=n>TotalWeight</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ECount</span><span class=p>,</span> <span class=n>NextEdge</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SetType</span> <span class=n>VSet</span><span class=p>;</span> <span class=cm>/* 顶点数组 */</span>
</span></span><span class=line><span class=cl>    <span class=n>Edge</span> <span class=n>ESet</span><span class=p>;</span>    <span class=cm>/* 边数组 */</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=nf>InitializeVSet</span><span class=p>(</span> <span class=n>VSet</span><span class=p>,</span> <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span> <span class=p>);</span> <span class=cm>/* 初始化顶点并查集 */</span>
</span></span><span class=line><span class=cl>    <span class=n>ESet</span> <span class=o>=</span> <span class=p>(</span><span class=n>Edge</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>ENode</span><span class=p>)</span><span class=o>*</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Ne</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>InitializeESet</span><span class=p>(</span> <span class=n>Graph</span><span class=p>,</span> <span class=n>ESet</span> <span class=p>);</span> <span class=cm>/* 初始化边的最小堆 */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 创建包含所有顶点但没有边的图。注意用邻接表版本 */</span>
</span></span><span class=line><span class=cl>    <span class=n>MST</span> <span class=o>=</span> <span class=nf>CreateGraph</span><span class=p>(</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>TotalWeight</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=cm>/* 初始化权重和     */</span>
</span></span><span class=line><span class=cl>    <span class=n>ECount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>      <span class=cm>/* 初始化收录的边数 */</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>NextEdge</span> <span class=o>=</span> <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Ne</span><span class=p>;</span> <span class=cm>/* 原始边集的规模 */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span> <span class=n>ECount</span> <span class=o>&lt;</span> <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=o>-</span><span class=mi>1</span> <span class=p>)</span> <span class=p>{</span>  <span class=cm>/* 当收集的边不足以构成树时 */</span>
</span></span><span class=line><span class=cl>        <span class=n>NextEdge</span> <span class=o>=</span> <span class=nf>GetEdge</span><span class=p>(</span> <span class=n>ESet</span><span class=p>,</span> <span class=n>NextEdge</span> <span class=p>);</span> <span class=cm>/* 从边集中得到最小边的位置 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>NextEdge</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=cm>/* 边集已空 */</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 如果该边的加入不构成回路，即两端结点不属于同一连通集 */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span> <span class=nf>CheckCycle</span><span class=p>(</span> <span class=n>VSet</span><span class=p>,</span> <span class=n>ESet</span><span class=p>[</span><span class=n>NextEdge</span><span class=p>].</span><span class=n>V1</span><span class=p>,</span> <span class=n>ESet</span><span class=p>[</span><span class=n>NextEdge</span><span class=p>].</span><span class=n>V2</span> <span class=p>)</span><span class=o>==</span><span class=nb>true</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 将该边插入MST */</span>
</span></span><span class=line><span class=cl>            <span class=nf>InsertEdge</span><span class=p>(</span> <span class=n>MST</span><span class=p>,</span> <span class=n>ESet</span><span class=o>+</span><span class=n>NextEdge</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>TotalWeight</span> <span class=o>+=</span> <span class=n>ESet</span><span class=p>[</span><span class=n>NextEdge</span><span class=p>].</span><span class=n>Weight</span><span class=p>;</span> <span class=cm>/* 累计权重 */</span>
</span></span><span class=line><span class=cl>            <span class=n>ECount</span><span class=o>++</span><span class=p>;</span> <span class=cm>/* 生成树中边数加1 */</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span> <span class=n>ECount</span> <span class=o>&lt;</span> <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=o>-</span><span class=mi>1</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>TotalWeight</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=cm>/* 设置错误标记，表示生成树不存在 */</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>TotalWeight</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>时间复杂度T=O(|E|log|E|)</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://h-jch.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></li></ul><nav class=paginav><a class=prev href=https://h-jch.github.io/posts/code/topsort/><span class=title>« Prev</span><br><span>拓扑排序</span></a>
<a class=next href=https://h-jch.github.io/posts/code/shortest-path/><span class=title>Next »</span><br><span>最短路径问题</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://h-jch.github.io>Kei's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>