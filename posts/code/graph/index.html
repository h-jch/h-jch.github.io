<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>图 | Kei's Blog</title><meta name=keywords content="数据结构"><meta name=description content="基本概念 图表示多对多的关系。包含 一组顶点：通常用V(Vertex)表示顶点集合 一组边：通常用E(Edge)表示边的集合 边是顶点对：(v,w)"><meta name=author content="kei"><link rel=canonical href=https://h-jch.github.io/posts/code/graph/><link crossorigin=anonymous href=/assets/css/stylesheet.678b5c47efa744d2e0dd0d61101075e6aecdc9a0631e7ad8538f4ec0cca79273.css integrity="sha256-Z4tcR++nRNLg3Q1hEBB15q7NyaBjHnrYU49OwMynknM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://h-jch.github.io/images/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://h-jch.github.io/images/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://h-jch.github.io/images/avatar.png><link rel=apple-touch-icon href=https://h-jch.github.io/images/avatar.png><link rel=mask-icon href=https://h-jch.github.io/images/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="图"><meta property="og:description" content="基本概念 图表示多对多的关系。包含 一组顶点：通常用V(Vertex)表示顶点集合 一组边：通常用E(Edge)表示边的集合 边是顶点对：(v,w)"><meta property="og:type" content="article"><meta property="og:url" content="https://h-jch.github.io/posts/code/graph/"><meta property="og:image" content="https://h-jch.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-07-27T23:30:00+08:00"><meta property="article:modified_time" content="2019-07-27T23:30:00+08:00"><meta property="og:site_name" content="Kei's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://h-jch.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="图"><meta name=twitter:description content="基本概念 图表示多对多的关系。包含 一组顶点：通常用V(Vertex)表示顶点集合 一组边：通常用E(Edge)表示边的集合 边是顶点对：(v,w)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://h-jch.github.io/posts/"},{"@type":"ListItem","position":3,"name":"图","item":"https://h-jch.github.io/posts/code/graph/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"图","name":"图","description":"基本概念 图表示多对多的关系。包含 一组顶点：通常用V(Vertex)表示顶点集合 一组边：通常用E(Edge)表示边的集合 边是顶点对：(v,w)","keywords":["数据结构"],"articleBody":"基本概念 图表示多对多的关系。包含\n一组顶点：通常用V(Vertex)表示顶点集合 一组边：通常用E(Edge)表示边的集合 边是顶点对：(v,w)是集合E的元素，其中v，w是集合V的元素 有向边表示从v指向w的边(单行线) 不考虑重边和自回路 抽象数据类型定义 类型名称：图 数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成 操作集：对于任意图G，以及v，e\nGraph Create()：建立并返回空图 Graph InsertVertex(Graph G, Vertex v)：将v插入G Graph InsertEdge(Graph G, Edge e)：将e插入G void DFS(Graph G, Vertex v)：从顶点v出发深度优先遍历图G void BFS(Graph G, Vertex v)：从顶点v出发广度优先遍历图G void ShortestPath(Graph G, Vertex v, int Dist[])：计算图G中顶点v到任意其他顶点的最短距离 void MST(Graph G)：计算图G的最小生成树 图的表示 图有两种表示方法，邻接矩阵和邻接表\n我们可以创建一个二维数组G[N][N]，若是G中的边，则G[i][j]=1，否则为0。对于有向图，邻接矩阵是对称的，而对于无向图则不是。对于网络，G[i][j]的值是边的权重，如果没有边，则为-∞。\n邻接矩阵的优点\n直观、简单、好理解 方便检查任意一对顶点间是否存在边 方便找任一顶点的所有“邻接点”（有边直接相连的顶点） 方便计算任一顶点的“度”（从该点出发的边数为“出度”，指向该点的边数为“入度”） 无向图：对应行（或列）非0元素的个数 有向图：对应行非0元素的个数是“出度”，对应列非0元素的个数是“入度” 邻接矩阵的缺点\n浪费空间：存稀疏图（点很多而边很少）有大量无效元素 对稠密图（特别是完全图）还是很合算的 浪费时间：统计稀疏图中一共有多少条边 同时，我们可以创建一个指针数组G[N]，对应矩阵每行一个链表，只存非0元素。对于网络，链表结构中要增加权重的域。\n邻接表的优点\n方便找任一顶点的所有“邻接点” 节约稀疏图的空间 需要N个头指针+2E个结点（每个结点至少2个域） 方便计算任一顶点的“度” 无向图：任一顶点的度就是链表的长度 有向图：只能计算“出度”，需要构造“逆邻接表”（存指向自己的边）来方便计算“出度” 邻接表的缺点\n不方便检查任意一对顶点间是否存在边 邻接矩阵表示 结构体定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #define MaxVertexNum 100 #define INFINITY 65535 typedef int Vertex; //用顶点下标表示顶点，为整型 typedef int WeightType; typedef char DataType; typedef struct ENode *PtrToENode; struct ENode{ //边的定义 Vertex V1,V2; //有向边 WeightType Weight; //权重 }; typedef PtrToENode Edge; typedef struct GNode *PtrToGNode; struct GNode{ //图结点的定义 int Nv; //顶点数 int Ne; //边数 WeightType G[MaxVertexNum][MaxVertexNum]; //邻接矩阵 DataType Data[MaxVertexNum]; //存顶点的数据，如果顶点不存数据，可以省略 }; typedef PtrToGNode MGraph; 图的初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 MGraph CreateGraph(int VertexNum){ //初始化一个有VertexNum个顶点但没有边的图 Vertex V,W; MGraph Graph; Graph=(MGraph)malloc(sizeof(struct GNode)); //建立图 Graph-\u003eNv=VertexNum; Graph-\u003eNe=0; for(V=0;V\u003cGraph-\u003eNv;V++) //初始化邻接矩阵，顶点编号为0-(Nv-1) for(W=0;W\u003cGraph-\u003eNv;W++) Graph-\u003eG[V][W]=INFINITY; return Graph; } 边的插入 1 2 3 4 void InsertEdge(MGraph Graph, Edge E){ Graph-\u003eG[E-\u003eV1][E-\u003eV2]=E-\u003eWeight; //插入边 Graph-\u003eG[E-\u003eV2][E-\u003eV1]=E-\u003eWeight; //若是无向图，还要插入边 } 图的建立 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 MGraph BuildGraph(){ MGraph Graph; Edge E; Vertex V; int Nv,i; scanf(\"%d\",\u0026Nv); //读入顶点个数 Graph=CreateGraph(Nv); //初始化有Nv个顶点但没有边的图 scanf(\"%d\",\u0026(Graph-\u003eNe)); //读入边数 if(Graph-\u003eNe!=0){ E=(Edge)malloc(sizeof(struct ENode)); //建立边结点 for(i=0;i\u003cGraph-\u003eNe;i++){ scanf(\"%d %d %d\",\u0026(E-\u003eV1),\u0026(E-\u003eV2),\u0026(E-\u003eWeight)); //读入边 InsertEdge(Graph,E); //插入边 } } for(V=0;V\u003cGraph-\u003eNv;V++) scanf(\"%d\",\u0026(Graph-\u003eData[V])); //如果顶点有数据，则读入数据 return Graph; } 邻接表表示 结构体定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #define MaxVertexNum 100 typedef int Vertex; //顶点下标表示顶点，为整型 typedef int WeightType; typedef char DataType; typedef struct ENode *PtrToENode; struct ENode{ //边的定义 Vertex V1,V2; //有向边 WeightType Weight; }; typedef PtrToENode Edge; typedef struct AdjVNode *PtrToAdjVNode; struct AdjVNode{ //邻接点的定义 Vertex AdjV; //邻接点下标 WeightType Weight; //边权重 PtrToAdjVNode Next; //指向下一个邻接点的指针 }; typedef struct Vnode{ //顶点表头结点的定义 PtrToAdjVNode FirstEdge; //边表头指针 DataType Data; //存顶点的数据 }AdjList[MaxVertexNum]; //AdjList是邻接表类型的数组 typedef struct GNode *PtrToGNode; struct GNode{ //图结点的定义 int Nv; //顶点数 int Ne; //边数 AdjList G; //邻接表 }; typedef PtrToGNode LGraph; 图的初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 LGraph CreateGraph(int VertexNum){ //初始化一个有VertexNum个顶点但没有边的图 Vertex V; LGraph Graph; Graph=(LGraph)malloc(sizeof(struct GNode)); //建立图 Graph-\u003eNv=VertexNum; Graph-\u003eVe=0; for(V=0;V\u003cGraph-\u003eNv;V++) //初始化邻接表头指针，定点编号0-(Graph-\u003eNv-1) Graph-\u003eG[V].FirstEdge=NULL; return Graph; } 边的插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void InsertEdge(LGraph Graph, Edge E){ PtrToAdjVNode NewNode; //插入边 NewNode=(PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); //为V2建立新的邻接点 NewNode-\u003eAdjV=E-\u003eV2; NewNode-\u003eWeight=E-\u003eWeight; //将V2插入V1的表头 NewNode-\u003eNext=Graph-\u003eG[E-\u003eV1].FirstEdge; Graph-\u003eG[E-\u003eV1].FirstEdge=NewNode; //若是无向图，还要插入边 NewNode=(PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); //为V1建立新的邻接点 NewNode-\u003eAdjV=E-\u003eV1; NewNode-\u003eWeight=E-\u003eWeight; //将V1插入V2的表头 NewNode-\u003eNext=Graph-\u003eG[E-\u003eV2].FirstEdge; Graph-\u003eG[E-\u003eV1].FirstEdge=NewNode; } 图的建立 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 LGraph BuildGraph(){ LGraph Graph; Edge E; Vertex V; int Nv,i; scanf(\"%d\",\u0026Nv); //读入顶点个数 Graph=CreateGraph(Nv); //初始化有Nv个顶点但没有边的图 scanf(\"%d\",\u0026(Graph-\u003eNe)); //读入边数 if(Graph-\u003eNe!=0){ E=(Edge)malloc(sizeof(struct ENode)); //建立边结点 for(i=0;i\u003cGraph-\u003eNe;i++){ scanf(\"%d %d %d\",\u0026(E-\u003eV1),\u0026(E-\u003eV2),\u0026(E-\u003eWeight)); //读入边的起点、终点、权重 InsertEdge(Graph,E); //插入边 } } for(V=0;V\u003cGraph-\u003eNv;V++) //如果顶点有数据，读入数据 scanf(\"%d\",\u0026(Graph-\u003eG[V].Data)); return Graph; } 图的遍历 图的遍历有两种方法，深度优先搜索(DFS)和广度优先搜索(BFS)。\n深度优先搜索 图的深度优先搜索类似于树的先序遍历。若有N个顶点、E条边，时间复杂度为\n用邻接表存储图，有O(N+E) 用邻接矩阵存储图，有O(N^2) 伪代码如下：\n1 2 3 4 5 6 void DFS(Vertex V){ visited[V]=true; for(V的每个邻接点W) if(!visited[W]) DFS(W); } C语言代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void Visit(Vertex V){ printf(\"正在访问顶点%d\",V); } void DFS(LGraph Graph, Vertex V, void (*Visit)(Vertex)){ //以V为出发点对邻接表存储的图Graph进行DFS PtrToAdjVNode W; Visit(V); //访问第V个顶点 Visited[V]=true; //Visited[]为全局变量，初始化为false，已访问则标记为true for(W=Graph-\u003eG[V].FirstEdge;W;W=W-\u003eNext) //对V的每个邻接点W-\u003eAdjV if(!Visited[W-\u003eAdjV]) //若W-\u003eAdjV未被访问 DFS(Graph,W-\u003eAdjV,Visit); //则递归访问 } 广度优先搜索 图的广度优先搜索类似于树的层序遍历，需要使用队列。若有N个顶点、E条边，时间复杂度为\n用邻接表存储图，有O(N+E) 用邻接矩阵存储图，有O(N^2) 伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 void BFS(Vertex V){ visited[V]=true; Enqueue(V,Q); while(!IsEmpty(Q)){ V=Dequeue(Q); for(V的每个邻接点W) if(!visited[W]){ visited[W]=true; Enqueue(W,Q); } } } C语言代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool IsEdge(MGraph Graph, Vertex V, Vertex W){ //判断是否是图Graph中的一条边，即W是否是V的邻接点 return Graph-\u003eG[V][W]\u003cINFINITY?true:false; } void BFS(MGraph Graph, Vertex S, void (*Visit)(Vertex)){ //以S为出发点对邻接矩阵存储的图Graphj进行BFS Queue Q; Vertex V,W; Q=CreateQueue(MaxSize); //创建空队列 Visit(S); Visited[S]=true; AddQ(Q,S); //S入队 while(!IsEmpty(Q)){ V=DeleteQ(Q); //出队 for(W=0;W,Graph-\u003eNv;W++) //对于图中的每个顶点W if(!Visited[W]\u0026\u0026IsEdge(Graph,V,W)){ //如果W是V的临界点且未被访问过 Visit(W); Visited[W]=true; AddQ(Q,W); } } } ","wordCount":"2560","inLanguage":"en","datePublished":"2019-07-27T23:30:00+08:00","dateModified":"2019-07-27T23:30:00+08:00","author":[{"@type":"Person","name":"kei"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://h-jch.github.io/posts/code/graph/"},"publisher":{"@type":"Organization","name":"Kei's Blog","logo":{"@type":"ImageObject","url":"https://h-jch.github.io/images/avatar.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://h-jch.github.io accesskey=h title="Kei's Blog (Alt + H)"><img src=https://h-jch.github.io/images/avatar.png alt aria-label=logo height=35>Kei's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://h-jch.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://h-jch.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://h-jch.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://h-jch.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>图</h1><div class=post-meta><span title='2019-07-27 23:30:00 +0800 CST'>2019-07-27</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;2560 words&nbsp;·&nbsp;kei</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=基本概念>基本概念</a></li><li><a href=#%e6%8a%bd%e8%b1%a1%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%ae%9a%e4%b9%89 aria-label=抽象数据类型定义>抽象数据类型定义</a></li><li><a href=#%e5%9b%be%e7%9a%84%e8%a1%a8%e7%a4%ba aria-label=图的表示>图的表示</a></li><li><a href=#%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5%e8%a1%a8%e7%a4%ba aria-label=邻接矩阵表示>邻接矩阵表示</a><ul><ul><li><a href=#%e7%bb%93%e6%9e%84%e4%bd%93%e5%ae%9a%e4%b9%89 aria-label=结构体定义>结构体定义</a></li><li><a href=#%e5%9b%be%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=图的初始化>图的初始化</a></li><li><a href=#%e8%be%b9%e7%9a%84%e6%8f%92%e5%85%a5 aria-label=边的插入>边的插入</a></li><li><a href=#%e5%9b%be%e7%9a%84%e5%bb%ba%e7%ab%8b aria-label=图的建立>图的建立</a></li></ul></ul></li><li><a href=#%e9%82%bb%e6%8e%a5%e8%a1%a8%e8%a1%a8%e7%a4%ba aria-label=邻接表表示>邻接表表示</a><ul><ul><li><a href=#%e7%bb%93%e6%9e%84%e4%bd%93%e5%ae%9a%e4%b9%89-1 aria-label=结构体定义>结构体定义</a></li><li><a href=#%e5%9b%be%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96-1 aria-label=图的初始化>图的初始化</a></li><li><a href=#%e8%be%b9%e7%9a%84%e6%8f%92%e5%85%a5-1 aria-label=边的插入>边的插入</a></li><li><a href=#%e5%9b%be%e7%9a%84%e5%bb%ba%e7%ab%8b-1 aria-label=图的建立>图的建立</a></li></ul></ul></li><li><a href=#%e5%9b%be%e7%9a%84%e9%81%8d%e5%8e%86 aria-label=图的遍历>图的遍历</a><ul><ul><li><a href=#%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2 aria-label=深度优先搜索>深度优先搜索</a></li><li><a href=#%e5%b9%bf%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2 aria-label=广度优先搜索>广度优先搜索</a></li></ul></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=基本概念>基本概念<a hidden class=anchor aria-hidden=true href=#基本概念>#</a></h3><p>图表示多对多的关系。包含</p><ul><li>一组顶点：通常用V(Vertex)表示顶点集合</li><li>一组边：通常用E(Edge)表示边的集合<ul><li>边是顶点对：(v,w)是集合E的元素，其中v，w是集合V的元素</li><li>有向边&lt;v,w>表示从v指向w的边(单行线)</li><li>不考虑重边和自回路</li></ul></li></ul><h3 id=抽象数据类型定义>抽象数据类型定义<a hidden class=anchor aria-hidden=true href=#抽象数据类型定义>#</a></h3><p>类型名称：图
数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成
操作集：对于任意图G，以及v，e</p><ul><li>Graph Create()：建立并返回空图</li><li>Graph InsertVertex(Graph G, Vertex v)：将v插入G</li><li>Graph InsertEdge(Graph G, Edge e)：将e插入G</li><li>void DFS(Graph G, Vertex v)：从顶点v出发深度优先遍历图G</li><li>void BFS(Graph G, Vertex v)：从顶点v出发广度优先遍历图G</li><li>void ShortestPath(Graph G, Vertex v, int Dist[])：计算图G中顶点v到任意其他顶点的最短距离</li><li>void MST(Graph G)：计算图G的最小生成树</li></ul><h3 id=图的表示>图的表示<a hidden class=anchor aria-hidden=true href=#图的表示>#</a></h3><p>图有两种表示方法，邻接矩阵和邻接表</p><p>我们可以创建一个二维数组G[N][N]，若&lt;vi,vj>是G中的边，则G[i][j]=1，否则为0。对于有向图，邻接矩阵是对称的，而对于无向图则不是。对于网络，G[i][j]的值是边&lt;vi,vj>的权重，如果没有边，则为-∞。</p><p>邻接矩阵的优点</p><ul><li>直观、简单、好理解</li><li>方便检查任意一对顶点间是否存在边</li><li>方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</li><li>方便计算任一顶点的“度”（从该点出发的边数为“出度”，指向该点的边数为“入度”）<ul><li>无向图：对应行（或列）非0元素的个数</li><li>有向图：对应行非0元素的个数是“出度”，对应列非0元素的个数是“入度”</li></ul></li></ul><p>邻接矩阵的缺点</p><ul><li>浪费空间：存稀疏图（点很多而边很少）有大量无效元素<ul><li>对稠密图（特别是完全图）还是很合算的</li></ul></li><li>浪费时间：统计稀疏图中一共有多少条边</li></ul><p>同时，我们可以创建一个指针数组G[N]，对应矩阵每行一个链表，只存非0元素。对于网络，链表结构中要增加权重的域。</p><p>邻接表的优点</p><ul><li>方便找任一顶点的所有“邻接点”</li><li>节约稀疏图的空间<ul><li>需要N个头指针+2E个结点（每个结点至少2个域）</li></ul></li><li>方便计算任一顶点的“度”<ul><li>无向图：任一顶点的度就是链表的长度</li><li>有向图：只能计算“出度”，需要构造“逆邻接表”（存指向自己的边）来方便计算“出度”</li></ul></li></ul><p>邻接表的缺点</p><ul><li>不方便检查任意一对顶点间是否存在边</li></ul><h3 id=邻接矩阵表示>邻接矩阵表示<a hidden class=anchor aria-hidden=true href=#邻接矩阵表示>#</a></h3><h5 id=结构体定义>结构体定义<a hidden class=anchor aria-hidden=true href=#结构体定义>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define MaxVertexNum 100
</span></span></span><span class=line><span class=cl><span class=cp>#define INFINITY 65535
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>Vertex</span><span class=p>;</span>     <span class=c1>//用顶点下标表示顶点，为整型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=kt>int</span> <span class=n>WeightType</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>char</span> <span class=n>DataType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>ENode</span> <span class=o>*</span><span class=n>PtrToENode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>ENode</span><span class=p>{</span>   <span class=c1>//边的定义
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Vertex</span> <span class=n>V1</span><span class=p>,</span><span class=n>V2</span><span class=p>;</span>   <span class=c1>//有向边&lt;v1,v2&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>WeightType</span> <span class=n>Weight</span><span class=p>;</span>  <span class=c1>//权重
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToENode</span> <span class=n>Edge</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>GNode</span> <span class=o>*</span><span class=n>PtrToGNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>GNode</span><span class=p>{</span>   <span class=c1>//图结点的定义
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>Nv</span><span class=p>;</span>     <span class=c1>//顶点数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>Ne</span><span class=p>;</span>     <span class=c1>//边数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>WeightType</span> <span class=n>G</span><span class=p>[</span><span class=n>MaxVertexNum</span><span class=p>][</span><span class=n>MaxVertexNum</span><span class=p>];</span>   <span class=c1>//邻接矩阵
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DataType</span> <span class=n>Data</span><span class=p>[</span><span class=n>MaxVertexNum</span><span class=p>];</span>    <span class=c1>//存顶点的数据，如果顶点不存数据，可以省略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToGNode</span> <span class=n>MGraph</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=图的初始化>图的初始化<a hidden class=anchor aria-hidden=true href=#图的初始化>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>MGraph</span> <span class=nf>CreateGraph</span><span class=p>(</span><span class=kt>int</span> <span class=n>VertexNum</span><span class=p>){</span>  <span class=c1>//初始化一个有VertexNum个顶点但没有边的图
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Vertex</span> <span class=n>V</span><span class=p>,</span><span class=n>W</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>MGraph</span> <span class=n>Graph</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Graph</span><span class=o>=</span><span class=p>(</span><span class=n>MGraph</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>GNode</span><span class=p>));</span>     <span class=c1>//建立图
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=o>=</span><span class=n>VertexNum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Ne</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>V</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>V</span><span class=o>&lt;</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=p>;</span><span class=n>V</span><span class=o>++</span><span class=p>)</span>    <span class=c1>//初始化邻接矩阵，顶点编号为0-(Nv-1)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span><span class=p>(</span><span class=n>W</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>W</span><span class=o>&lt;</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=p>;</span><span class=n>W</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>V</span><span class=p>][</span><span class=n>W</span><span class=p>]</span><span class=o>=</span><span class=n>INFINITY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Graph</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=边的插入>边的插入<a hidden class=anchor aria-hidden=true href=#边的插入>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>InsertEdge</span><span class=p>(</span><span class=n>MGraph</span> <span class=n>Graph</span><span class=p>,</span> <span class=n>Edge</span> <span class=n>E</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V1</span><span class=p>][</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V2</span><span class=p>]</span><span class=o>=</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>Weight</span><span class=p>;</span>      <span class=c1>//插入边&lt;V1,V2&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V2</span><span class=p>][</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V1</span><span class=p>]</span><span class=o>=</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>Weight</span><span class=p>;</span>      <span class=c1>//若是无向图，还要插入边&lt;V2,V1&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=图的建立>图的建立<a hidden class=anchor aria-hidden=true href=#图的建立>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>MGraph</span> <span class=nf>BuildGraph</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>MGraph</span> <span class=n>Graph</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Edge</span> <span class=n>E</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Vertex</span> <span class=n>V</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Nv</span><span class=p>,</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=n>Nv</span><span class=p>);</span>     <span class=c1>//读入顶点个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Graph</span><span class=o>=</span><span class=nf>CreateGraph</span><span class=p>(</span><span class=n>Nv</span><span class=p>);</span>     <span class=c1>//初始化有Nv个顶点但没有边的图
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=p>(</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Ne</span><span class=p>));</span>     <span class=c1>//读入边数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Ne</span><span class=o>!=</span><span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>       <span class=n>E</span><span class=o>=</span><span class=p>(</span><span class=n>Edge</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>ENode</span><span class=p>));</span>     <span class=c1>//建立边结点
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Ne</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>          <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d %d %d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=p>(</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V1</span><span class=p>),</span><span class=o>&amp;</span><span class=p>(</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V2</span><span class=p>),</span><span class=o>&amp;</span><span class=p>(</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>Weight</span><span class=p>));</span>     <span class=c1>//读入边
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=nf>InsertEdge</span><span class=p>(</span><span class=n>Graph</span><span class=p>,</span><span class=n>E</span><span class=p>);</span>    <span class=c1>//插入边
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>V</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>V</span><span class=o>&lt;</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=p>;</span><span class=n>V</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=p>(</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Data</span><span class=p>[</span><span class=n>V</span><span class=p>]));</span>      <span class=c1>//如果顶点有数据，则读入数据
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Graph</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=邻接表表示>邻接表表示<a hidden class=anchor aria-hidden=true href=#邻接表表示>#</a></h3><h5 id=结构体定义-1>结构体定义<a hidden class=anchor aria-hidden=true href=#结构体定义-1>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define MaxVertexNum 100
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>Vertex</span><span class=p>;</span>     <span class=c1>//顶点下标表示顶点，为整型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=kt>int</span> <span class=n>WeightType</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>char</span> <span class=n>DataType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>ENode</span> <span class=o>*</span><span class=n>PtrToENode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>ENode</span><span class=p>{</span>     <span class=c1>//边的定义
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Vertex</span> <span class=n>V1</span><span class=p>,</span><span class=n>V2</span><span class=p>;</span>     <span class=c1>//有向边&lt;V1,V2&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>WeightType</span> <span class=n>Weight</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToENode</span> <span class=n>Edge</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>AdjVNode</span> <span class=o>*</span><span class=n>PtrToAdjVNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>AdjVNode</span><span class=p>{</span>     <span class=c1>//邻接点的定义
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Vertex</span> <span class=n>AdjV</span><span class=p>;</span>      <span class=c1>//邻接点下标
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>WeightType</span> <span class=n>Weight</span><span class=p>;</span>      <span class=c1>//边权重
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PtrToAdjVNode</span> <span class=n>Next</span><span class=p>;</span>     <span class=c1>//指向下一个邻接点的指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>Vnode</span><span class=p>{</span>      <span class=c1>//顶点表头结点的定义
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PtrToAdjVNode</span> <span class=n>FirstEdge</span><span class=p>;</span>      <span class=c1>//边表头指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DataType</span> <span class=n>Data</span><span class=p>;</span>       <span class=c1>//存顶点的数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=n>AdjList</span><span class=p>[</span><span class=n>MaxVertexNum</span><span class=p>];</span>       <span class=c1>//AdjList是邻接表类型的数组
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>GNode</span> <span class=o>*</span><span class=n>PtrToGNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>GNode</span><span class=p>{</span>     <span class=c1>//图结点的定义
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>Nv</span><span class=p>;</span>     <span class=c1>//顶点数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>Ne</span><span class=p>;</span>     <span class=c1>//边数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>AdjList</span> <span class=n>G</span><span class=p>;</span>     <span class=c1>//邻接表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToGNode</span> <span class=n>LGraph</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=图的初始化-1>图的初始化<a hidden class=anchor aria-hidden=true href=#图的初始化-1>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>LGraph</span> <span class=nf>CreateGraph</span><span class=p>(</span><span class=kt>int</span> <span class=n>VertexNum</span><span class=p>){</span>      <span class=c1>//初始化一个有VertexNum个顶点但没有边的图
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Vertex</span> <span class=n>V</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LGraph</span> <span class=n>Graph</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Graph</span><span class=o>=</span><span class=p>(</span><span class=n>LGraph</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>GNode</span><span class=p>));</span>     <span class=c1>//建立图
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=o>=</span><span class=n>VertexNum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Ve</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>V</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>V</span><span class=o>&lt;</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=p>;</span><span class=n>V</span><span class=o>++</span><span class=p>)</span>        <span class=c1>//初始化邻接表头指针，定点编号0-(Graph-&gt;Nv-1)
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>V</span><span class=p>].</span><span class=n>FirstEdge</span><span class=o>=</span><span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Graph</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=边的插入-1>边的插入<a hidden class=anchor aria-hidden=true href=#边的插入-1>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>InsertEdge</span><span class=p>(</span><span class=n>LGraph</span> <span class=n>Graph</span><span class=p>,</span> <span class=n>Edge</span> <span class=n>E</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>PtrToAdjVNode</span> <span class=n>NewNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//插入边&lt;V1,V2&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NewNode</span><span class=o>=</span><span class=p>(</span><span class=n>PtrToAdjVNode</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>AdjVNode</span><span class=p>));</span>     <span class=c1>//为V2建立新的邻接点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NewNode</span><span class=o>-&gt;</span><span class=n>AdjV</span><span class=o>=</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NewNode</span><span class=o>-&gt;</span><span class=n>Weight</span><span class=o>=</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>Weight</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//将V2插入V1的表头
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NewNode</span><span class=o>-&gt;</span><span class=n>Next</span><span class=o>=</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V1</span><span class=p>].</span><span class=n>FirstEdge</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V1</span><span class=p>].</span><span class=n>FirstEdge</span><span class=o>=</span><span class=n>NewNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//若是无向图，还要插入边&lt;V2,V1&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NewNode</span><span class=o>=</span><span class=p>(</span><span class=n>PtrToAdjVNode</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>AdjVNode</span><span class=p>));</span>     <span class=c1>//为V1建立新的邻接点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NewNode</span><span class=o>-&gt;</span><span class=n>AdjV</span><span class=o>=</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NewNode</span><span class=o>-&gt;</span><span class=n>Weight</span><span class=o>=</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>Weight</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//将V1插入V2的表头
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NewNode</span><span class=o>-&gt;</span><span class=n>Next</span><span class=o>=</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V2</span><span class=p>].</span><span class=n>FirstEdge</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V1</span><span class=p>].</span><span class=n>FirstEdge</span><span class=o>=</span><span class=n>NewNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=图的建立-1>图的建立<a hidden class=anchor aria-hidden=true href=#图的建立-1>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>LGraph</span> <span class=nf>BuildGraph</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>LGraph</span> <span class=n>Graph</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Edge</span> <span class=n>E</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Vertex</span> <span class=n>V</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>Nv</span><span class=p>,</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=n>Nv</span><span class=p>);</span>        <span class=c1>//读入顶点个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Graph</span><span class=o>=</span><span class=nf>CreateGraph</span><span class=p>(</span><span class=n>Nv</span><span class=p>);</span>      <span class=c1>//初始化有Nv个顶点但没有边的图
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=p>(</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Ne</span><span class=p>));</span>       <span class=c1>//读入边数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Ne</span><span class=o>!=</span><span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>E</span><span class=o>=</span><span class=p>(</span><span class=n>Edge</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>ENode</span><span class=p>));</span>       <span class=c1>//建立边结点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Ne</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d %d %d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=p>(</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V1</span><span class=p>),</span><span class=o>&amp;</span><span class=p>(</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>V2</span><span class=p>),</span><span class=o>&amp;</span><span class=p>(</span><span class=n>E</span><span class=o>-&gt;</span><span class=n>Weight</span><span class=p>));</span>       <span class=c1>//读入边的起点、终点、权重
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>InsertEdge</span><span class=p>(</span><span class=n>Graph</span><span class=p>,</span><span class=n>E</span><span class=p>);</span>        <span class=c1>//插入边
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>V</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>V</span><span class=o>&lt;</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=p>;</span><span class=n>V</span><span class=o>++</span><span class=p>)</span>        <span class=c1>//如果顶点有数据，读入数据
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=p>(</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>V</span><span class=p>].</span><span class=n>Data</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Graph</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=图的遍历>图的遍历<a hidden class=anchor aria-hidden=true href=#图的遍历>#</a></h3><p>图的遍历有两种方法，深度优先搜索(DFS)和广度优先搜索(BFS)。</p><h5 id=深度优先搜索>深度优先搜索<a hidden class=anchor aria-hidden=true href=#深度优先搜索>#</a></h5><p>图的深度优先搜索类似于树的先序遍历。若有N个顶点、E条边，时间复杂度为</p><ul><li>用邻接表存储图，有O(N+E)</li><li>用邻接矩阵存储图，有O(N^2)</li></ul><p>伪代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>DFS</span><span class=p>(</span><span class=n>Vertex</span> <span class=n>V</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=n>V</span><span class=p>]</span><span class=o>=</span><span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>V的每个邻接点W</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>visited</span><span class=p>[</span><span class=n>W</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=nf>DFS</span><span class=p>(</span><span class=n>W</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>C语言代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Visit</span><span class=p>(</span><span class=n>Vertex</span> <span class=n>V</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;正在访问顶点%d&#34;</span><span class=p>,</span><span class=n>V</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>DFS</span><span class=p>(</span><span class=n>LGraph</span> <span class=n>Graph</span><span class=p>,</span> <span class=n>Vertex</span> <span class=n>V</span><span class=p>,</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>Visit</span><span class=p>)(</span><span class=n>Vertex</span><span class=p>)){</span>        <span class=c1>//以V为出发点对邻接表存储的图Graph进行DFS
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PtrToAdjVNode</span> <span class=n>W</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>Visit</span><span class=p>(</span><span class=n>V</span><span class=p>);</span>       <span class=c1>//访问第V个顶点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Visited</span><span class=p>[</span><span class=n>V</span><span class=p>]</span><span class=o>=</span><span class=nb>true</span><span class=p>;</span>        <span class=c1>//Visited[]为全局变量，初始化为false，已访问则标记为true
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>W</span><span class=o>=</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>V</span><span class=p>].</span><span class=n>FirstEdge</span><span class=p>;</span><span class=n>W</span><span class=p>;</span><span class=n>W</span><span class=o>=</span><span class=n>W</span><span class=o>-&gt;</span><span class=n>Next</span><span class=p>)</span>        <span class=c1>//对V的每个邻接点W-&gt;AdjV
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>Visited</span><span class=p>[</span><span class=n>W</span><span class=o>-&gt;</span><span class=n>AdjV</span><span class=p>])</span>       <span class=c1>//若W-&gt;AdjV未被访问
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>DFS</span><span class=p>(</span><span class=n>Graph</span><span class=p>,</span><span class=n>W</span><span class=o>-&gt;</span><span class=n>AdjV</span><span class=p>,</span><span class=n>Visit</span><span class=p>);</span>       <span class=c1>//则递归访问
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=广度优先搜索>广度优先搜索<a hidden class=anchor aria-hidden=true href=#广度优先搜索>#</a></h5><p>图的广度优先搜索类似于树的层序遍历，需要使用队列。若有N个顶点、E条边，时间复杂度为</p><ul><li>用邻接表存储图，有O(N+E)</li><li>用邻接矩阵存储图，有O(N^2)</li></ul><p>伪代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>BFS</span><span class=p>(</span><span class=n>Vertex</span> <span class=n>V</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=n>V</span><span class=p>]</span><span class=o>=</span><span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>Enqueue</span><span class=p>(</span><span class=n>V</span><span class=p>,</span><span class=n>Q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=o>!</span><span class=nf>IsEmpty</span><span class=p>(</span><span class=n>Q</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>        <span class=n>V</span><span class=o>=</span><span class=nf>Dequeue</span><span class=p>(</span><span class=n>Q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=n>V的每个邻接点W</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>visited</span><span class=p>[</span><span class=n>W</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                <span class=n>visited</span><span class=p>[</span><span class=n>W</span><span class=p>]</span><span class=o>=</span><span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=nf>Enqueue</span><span class=p>(</span><span class=n>W</span><span class=p>,</span><span class=n>Q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>C语言代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>IsEdge</span><span class=p>(</span><span class=n>MGraph</span> <span class=n>Graph</span><span class=p>,</span> <span class=n>Vertex</span> <span class=n>V</span><span class=p>,</span> <span class=n>Vertex</span> <span class=n>W</span><span class=p>){</span>      <span class=c1>//判断&lt;V,W&gt;是否是图Graph中的一条边，即W是否是V的邻接点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>Graph</span><span class=o>-&gt;</span><span class=n>G</span><span class=p>[</span><span class=n>V</span><span class=p>][</span><span class=n>W</span><span class=p>]</span><span class=o>&lt;</span><span class=n>INFINITY</span><span class=o>?</span><span class=nb>true</span><span class=o>:</span><span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>BFS</span><span class=p>(</span><span class=n>MGraph</span> <span class=n>Graph</span><span class=p>,</span> <span class=n>Vertex</span> <span class=n>S</span><span class=p>,</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>Visit</span><span class=p>)(</span><span class=n>Vertex</span><span class=p>)){</span>        <span class=c1>//以S为出发点对邻接矩阵存储的图Graphj进行BFS
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Queue</span> <span class=n>Q</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Vertex</span> <span class=n>V</span><span class=p>,</span><span class=n>W</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Q</span><span class=o>=</span><span class=nf>CreateQueue</span><span class=p>(</span><span class=n>MaxSize</span><span class=p>);</span>     <span class=c1>//创建空队列
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>Visit</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Visited</span><span class=p>[</span><span class=n>S</span><span class=p>]</span><span class=o>=</span><span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>AddQ</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span><span class=n>S</span><span class=p>);</span>      <span class=c1>//S入队
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=o>!</span><span class=nf>IsEmpty</span><span class=p>(</span><span class=n>Q</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>        <span class=n>V</span><span class=o>=</span><span class=nf>DeleteQ</span><span class=p>(</span><span class=n>Q</span><span class=p>);</span>       <span class=c1>//出队
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span><span class=p>(</span><span class=n>W</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>W</span><span class=p>,</span><span class=n>Graph</span><span class=o>-&gt;</span><span class=n>Nv</span><span class=p>;</span><span class=n>W</span><span class=o>++</span><span class=p>)</span>        <span class=c1>//对于图中的每个顶点W
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>Visited</span><span class=p>[</span><span class=n>W</span><span class=p>]</span><span class=o>&amp;&amp;</span><span class=nf>IsEdge</span><span class=p>(</span><span class=n>Graph</span><span class=p>,</span><span class=n>V</span><span class=p>,</span><span class=n>W</span><span class=p>)){</span>     <span class=c1>//如果W是V的临界点且未被访问过
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>Visit</span><span class=p>(</span><span class=n>W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>Visited</span><span class=p>[</span><span class=n>W</span><span class=p>]</span><span class=o>=</span><span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=nf>AddQ</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span><span class=n>W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://h-jch.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></li></ul><nav class=paginav><a class=prev href=https://h-jch.github.io/posts/code/shortest-path/><span class=title>« Prev</span><br><span>最短路径问题</span></a>
<a class=next href=https://h-jch.github.io/posts/code/sort/><span class=title>Next »</span><br><span>排序算法</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://h-jch.github.io>Kei's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>