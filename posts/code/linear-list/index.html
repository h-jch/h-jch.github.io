<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>线性表 | Kei's Blog</title><meta name=keywords content="数据结构"><meta name=description content="线性表是最基本的数据结构。 基本概念 线性表(Linear List)：由同类型数据元素构成有序序列的线性结构。 表中元素个数称为线性表的长度 线性表"><meta name=author content="kei"><link rel=canonical href=https://h-jch.github.io/posts/code/linear-list/><link crossorigin=anonymous href=/assets/css/stylesheet.678b5c47efa744d2e0dd0d61101075e6aecdc9a0631e7ad8538f4ec0cca79273.css integrity="sha256-Z4tcR++nRNLg3Q1hEBB15q7NyaBjHnrYU49OwMynknM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://h-jch.github.io/images/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://h-jch.github.io/images/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://h-jch.github.io/images/avatar.png><link rel=apple-touch-icon href=https://h-jch.github.io/images/avatar.png><link rel=mask-icon href=https://h-jch.github.io/images/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="线性表"><meta property="og:description" content="线性表是最基本的数据结构。 基本概念 线性表(Linear List)：由同类型数据元素构成有序序列的线性结构。 表中元素个数称为线性表的长度 线性表"><meta property="og:type" content="article"><meta property="og:url" content="https://h-jch.github.io/posts/code/linear-list/"><meta property="og:image" content="https://h-jch.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-06-19T23:30:00+08:00"><meta property="article:modified_time" content="2019-06-19T23:30:00+08:00"><meta property="og:site_name" content="Kei's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://h-jch.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="线性表"><meta name=twitter:description content="线性表是最基本的数据结构。 基本概念 线性表(Linear List)：由同类型数据元素构成有序序列的线性结构。 表中元素个数称为线性表的长度 线性表"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://h-jch.github.io/posts/"},{"@type":"ListItem","position":3,"name":"线性表","item":"https://h-jch.github.io/posts/code/linear-list/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"线性表","name":"线性表","description":"线性表是最基本的数据结构。 基本概念 线性表(Linear List)：由同类型数据元素构成有序序列的线性结构。 表中元素个数称为线性表的长度 线性表","keywords":["数据结构"],"articleBody":"线性表是最基本的数据结构。\n基本概念 线性表(Linear List)：由同类型数据元素构成有序序列的线性结构。\n表中元素个数称为线性表的长度 线性表没有元素时称为空表 表起始位置为表头，表结束位置为表尾\n抽象数据类型描述 类型名称：线性表 数据对象集：线性表是n个元素构成的有序序列(a1,a2,···,an) 操作集：线性表L属于List，整数i表示位置，元素X属于ElementType\nList MakeEmpty()：初始化一个空线性表L ElementType FindKth(List L, Position K)：根据位序K，返回相应元素 int Find(List L, ElementType X)：在线性表L中查找X的第一次出现位置 void Insert(List L, ElementType X, Position i)：在位序i前插入一个新元素X void Delete(List L, Position i)：删除指定位序i的元素 int Length(List L)：返回线性表L的长度n 顺序存储实现 线性表的顺序存储实现利用数组的连续存储空间顺序存放线性表的个元素，也叫做顺序表。\n结构体定义 1 2 3 4 5 6 typedef int Position; typedef struct LNode *List; struct LNode{ ElementType Data[MAXSIZE]; //用数组实现，MAXSIZE为最大存储容量 Postion Last; //末尾元素位置 }; 访问下标为i的元素：L.Data[i]或PtrL-\u003eData[i] 线性表的长度：L.Last+1或PtrL-\u003eL+1\n初始化 初始化也就是建立空的顺序表\n1 2 3 4 5 6 List MakeEmpty(){ List L; L=(List)malloc(sizeof(struct LNode)); //内存分配 L-\u003eLast=-1; //没有元素时为-1\treturn L; } 查找 1 2 3 4 5 6 7 8 9 Position Find(List L, ElementType X){ Position i=0; while(i\u003c=L-\u003eLast\u0026\u0026L-\u003eData[i]!=X) i++; if(i\u003eL-\u003eLast) return -1; //没找到，返回-1 else return i; //找到，返回存储位置 } 查找成功的平均比较次数为(n+1)/2，平均时间性能为O(n)。\n插入 要在第i个位置上插入一个值为X的元素，先从表尾开始到位序为i的元素依次往后移位，空出i，再将X插入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void Insert(List L, ElementType X, Position i){ Position j; if(L-\u003eLast==MAXSIZE-1){ printf(\"表满\"); return; } if(i\u003c0||i\u003eL-\u003eLast+1){ printf(\"位置不合法\"); return; } for(j=L-\u003eLast; j\u003e=i; --j) L-\u003eData[j+1]=L-\u003eData[j]; //后移,第i个位置，数组下标为i-1 L-\u003eData[j]=X; //插入 L-\u003eLast++; //Last依旧是表尾 } 插入的平均移动次数为n/2，平均时间性能为O(n)。\n删除 要删除表的位序为i的元素，直接从i+1到表尾依次往前移位，覆盖前一个位置的元素。\n1 2 3 4 5 6 7 8 9 10 void Delete(List L, Position i){ Position j; if(i\u003c0||i\u003ePtrL-\u003eLast){ printf(\"不存在%d号元素\",i); return; } for(j=i; j\u003cPtrL-\u003eLast; ++j) PtrL-\u003eData[j]=PtrL-\u003eData[j+1]; //前移，第i个位置，数组下标为i-1 PtrL-\u003eLast--; } 删除的平均移动次数为(n-1)/2，平均时间性能为O(n)。\n链式存储实现 线性表的链式存储实现不要求逻辑上相邻的两个元素物理上也相邻，通过链建立起数据元素之间的逻辑关系，也叫做链表。 在链表中，每个结点除了要存储数据元素之外，还要存储一个指向其后继结点的指针。当然，结点可以有多个指针指向不同位置，而在此只讨论结点只有一个指针，即单链表。同时，结点有两个指针，一个指向前驱，一个指向后继，叫做双链表。\n结构体定义 1 2 3 4 5 6 7 typedef struct LNode *PtrToLNode; struct LNode{ ElementType Data; //数据元素 PtrToLNode Next; //指向后继的指针 }; typedef PtrToLNode Position; typedef PtrToLNode List; 求表长度 1 2 3 4 5 6 7 8 9 int Length(List L){ Position p=L; //p指向链表头结点 int j=0; while(p){ p=p-\u003eNext; ++j; //当前p指向第j个结点 } return j; } 时间性能为O(n)。\n查找 查找分为两种情况，一种是按序号查找，一种是按值查找。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Position FindKth(List L, int K){ //按序号查找，找第K个元素 Position p=L; int i=1; while(p-\u003eNext\u0026\u0026i\u003cK){ p=p-\u003eNext; ++i; } if(i==K) return p; //找到第K个，返回指针 else return NULL; //未找到 } Position Find(List L, ElementType X){ //按值查找，找元素X的位置 Positon p=L; while(p\u0026\u0026p-\u003eData!=X) p=p-\u003eNext; if(p) return p; else return NULL; } 查找的平均时间性能为O(n)。\n插入 要在结点P之前插入新结点，先构造一个新结点，再找到P之前的结点，然后修改指针，插入新结点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 void Insert(List L, ElementType X, Position P){ Position tmp, pre; for(pre=L; pre\u0026\u0026pre-\u003eNext!=P; pre=pre-\u003eNext) //找到P的前一个结点 ; if(pre==NULL) printf(\"插入位置参数错误\\n\"); else{ tmp=(Position)malloc(sizeof(struct LNode)); //分配内存，构造结点 tmp-\u003eData=X; tmp-\u003eNext=P; pre-\u003eNext=tmp; } } 平均查找次数为n/2，平均时间性能为O(n)。\n删除 要删除结点P，先找到P之前的结点，然后修改指针，最后释放内存空间。\n1 2 3 4 5 6 7 8 9 10 11 12 void Delete(List L, Position P){ Position tmp, pre; for(pre=L; pre\u0026\u0026pre-\u003eNext!=P; pre=pre-\u003eNext) //找到P的前一个结点 ; if(pre==NULL||P==NULL) printf(\"删除位置参数错误\\n\"); else{ tmp=P pre-\u003eNext=tmp-\u003eNext; //删除P free(tmp); //释放空间 } } 平均查找次数为n/2，平均时间性能为O(n)。\n","wordCount":"1653","inLanguage":"en","datePublished":"2019-06-19T23:30:00+08:00","dateModified":"2019-06-19T23:30:00+08:00","author":[{"@type":"Person","name":"kei"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://h-jch.github.io/posts/code/linear-list/"},"publisher":{"@type":"Organization","name":"Kei's Blog","logo":{"@type":"ImageObject","url":"https://h-jch.github.io/images/avatar.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://h-jch.github.io accesskey=h title="Kei's Blog (Alt + H)"><img src=https://h-jch.github.io/images/avatar.png alt aria-label=logo height=35>Kei's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://h-jch.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://h-jch.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://h-jch.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://h-jch.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>线性表</h1><div class=post-meta><span title='2019-06-19 23:30:00 +0800 CST'>2019-06-19</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;1653 words&nbsp;·&nbsp;kei</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=基本概念>基本概念</a></li><li><a href=#%e6%8a%bd%e8%b1%a1%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e6%8f%8f%e8%bf%b0 aria-label=抽象数据类型描述>抽象数据类型描述</a></li><li><a href=#%e9%a1%ba%e5%ba%8f%e5%ad%98%e5%82%a8%e5%ae%9e%e7%8e%b0 aria-label=顺序存储实现>顺序存储实现</a><ul><ul><li><a href=#%e7%bb%93%e6%9e%84%e4%bd%93%e5%ae%9a%e4%b9%89 aria-label=结构体定义>结构体定义</a></li><li><a href=#%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=初始化>初始化</a></li><li><a href=#%e6%9f%a5%e6%89%be aria-label=查找>查找</a></li><li><a href=#%e6%8f%92%e5%85%a5 aria-label=插入>插入</a></li><li><a href=#%e5%88%a0%e9%99%a4 aria-label=删除>删除</a></li></ul></ul></li><li><a href=#%e9%93%be%e5%bc%8f%e5%ad%98%e5%82%a8%e5%ae%9e%e7%8e%b0 aria-label=链式存储实现>链式存储实现</a><ul><ul><li><a href=#%e7%bb%93%e6%9e%84%e4%bd%93%e5%ae%9a%e4%b9%89-1 aria-label=结构体定义>结构体定义</a></li><li><a href=#%e6%b1%82%e8%a1%a8%e9%95%bf%e5%ba%a6 aria-label=求表长度>求表长度</a></li><li><a href=#%e6%9f%a5%e6%89%be-1 aria-label=查找>查找</a></li><li><a href=#%e6%8f%92%e5%85%a5-1 aria-label=插入>插入</a></li><li><a href=#%e5%88%a0%e9%99%a4-1 aria-label=删除>删除</a></li></ul></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>线性表是最基本的数据结构。</p><h3 id=基本概念>基本概念<a hidden class=anchor aria-hidden=true href=#基本概念>#</a></h3><p>线性表(Linear List)：由同类型数据元素构成有序序列的线性结构。</p><blockquote><p>表中元素个数称为线性表的长度
线性表没有元素时称为空表
表起始位置为表头，表结束位置为表尾</p></blockquote><h3 id=抽象数据类型描述>抽象数据类型描述<a hidden class=anchor aria-hidden=true href=#抽象数据类型描述>#</a></h3><p>类型名称：线性表
数据对象集：线性表是n个元素构成的有序序列(a1,a2,···,an)
操作集：线性表L属于List，整数i表示位置，元素X属于ElementType</p><ul><li>List MakeEmpty()：初始化一个空线性表L</li><li>ElementType FindKth(List L, Position K)：根据位序K，返回相应元素</li><li>int Find(List L, ElementType X)：在线性表L中查找X的第一次出现位置</li><li>void Insert(List L, ElementType X, Position i)：在位序i前插入一个新元素X</li><li>void Delete(List L, Position i)：删除指定位序i的元素</li><li>int Length(List L)：返回线性表L的长度n</li></ul><h3 id=顺序存储实现>顺序存储实现<a hidden class=anchor aria-hidden=true href=#顺序存储实现>#</a></h3><p>线性表的顺序存储实现利用<strong>数组</strong>的连续存储空间顺序存放线性表的个元素，也叫做<strong>顺序表</strong>。</p><h5 id=结构体定义>结构体定义<a hidden class=anchor aria-hidden=true href=#结构体定义>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>Position</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>LNode</span> <span class=o>*</span><span class=n>List</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>LNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>Data</span><span class=p>[</span><span class=n>MAXSIZE</span><span class=p>];</span>      <span class=c1>//用数组实现，MAXSIZE为最大存储容量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Postion</span> <span class=n>Last</span><span class=p>;</span>       <span class=c1>//末尾元素位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>访问下标为i的元素：L.Data[i]或PtrL->Data[i]
线性表的长度：L.Last+1或PtrL->L+1</p><h5 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h5><p>初始化也就是建立空的顺序表</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>List</span> <span class=nf>MakeEmpty</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span><span class=o>=</span><span class=p>(</span><span class=n>List</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>LNode</span><span class=p>));</span>   <span class=c1>//内存分配
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>L</span><span class=o>-&gt;</span><span class=n>Last</span><span class=o>=-</span><span class=mi>1</span><span class=p>;</span>     <span class=c1>//没有元素时为-1	
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=查找>查找<a hidden class=anchor aria-hidden=true href=#查找>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>Position</span> <span class=nf>Find</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>L</span><span class=o>-&gt;</span><span class=n>Last</span><span class=o>&amp;&amp;</span><span class=n>L</span><span class=o>-&gt;</span><span class=n>Data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>!=</span><span class=n>X</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>&gt;</span><span class=n>L</span><span class=o>-&gt;</span><span class=n>Last</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>      <span class=c1>//没找到，返回-1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>i</span><span class=p>;</span>       <span class=c1>//找到，返回存储位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>查找成功的平均比较次数为(n+1)/2，平均时间性能为O(n)。</p><h5 id=插入>插入<a hidden class=anchor aria-hidden=true href=#插入>#</a></h5><p>要在第i个位置上插入一个值为X的元素，先从表尾开始到位序为i的元素依次往后移位，空出i，再将X插入。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Insert</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>,</span> <span class=n>Position</span> <span class=n>i</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>L</span><span class=o>-&gt;</span><span class=n>Last</span><span class=o>==</span><span class=n>MAXSIZE</span><span class=o>-</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;表满&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>||</span><span class=n>i</span><span class=o>&gt;</span><span class=n>L</span><span class=o>-&gt;</span><span class=n>Last</span><span class=o>+</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;位置不合法&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=n>L</span><span class=o>-&gt;</span><span class=n>Last</span><span class=p>;</span> <span class=n>j</span><span class=o>&gt;=</span><span class=n>i</span><span class=p>;</span> <span class=o>--</span><span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>L</span><span class=o>-&gt;</span><span class=n>Data</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=n>L</span><span class=o>-&gt;</span><span class=n>Data</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>    <span class=c1>//后移,第i个位置，数组下标为i-1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>L</span><span class=o>-&gt;</span><span class=n>Data</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>X</span><span class=p>;</span>   <span class=c1>//插入
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>L</span><span class=o>-&gt;</span><span class=n>Last</span><span class=o>++</span><span class=p>;</span>      <span class=c1>//Last依旧是表尾
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>插入的平均移动次数为n/2，平均时间性能为O(n)。</p><h5 id=删除>删除<a hidden class=anchor aria-hidden=true href=#删除>#</a></h5><p>要删除表的位序为i的元素，直接从i+1到表尾依次往前移位，覆盖前一个位置的元素。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Delete</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=n>Position</span> <span class=n>i</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>||</span><span class=n>i</span><span class=o>&gt;</span><span class=n>PtrL</span><span class=o>-&gt;</span><span class=n>Last</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;不存在%d号元素&#34;</span><span class=p>,</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>&lt;</span><span class=n>PtrL</span><span class=o>-&gt;</span><span class=n>Last</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>PtrL</span><span class=o>-&gt;</span><span class=n>Data</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>PtrL</span><span class=o>-&gt;</span><span class=n>Data</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>      <span class=c1>//前移，第i个位置，数组下标为i-1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PtrL</span><span class=o>-&gt;</span><span class=n>Last</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>删除的平均移动次数为(n-1)/2，平均时间性能为O(n)。</p><h3 id=链式存储实现>链式存储实现<a hidden class=anchor aria-hidden=true href=#链式存储实现>#</a></h3><p>线性表的链式存储实现不要求逻辑上相邻的两个元素物理上也相邻，通过<strong>链</strong>建立起数据元素之间的逻辑关系，也叫做<strong>链表</strong>。
在链表中，每个结点除了要存储数据元素之外，还要存储一个指向其后继结点的指针。当然，结点可以有多个指针指向不同位置，而在此只讨论结点只有一个指针，即单链表。同时，结点有两个指针，一个指向前驱，一个指向后继，叫做双链表。</p><h5 id=结构体定义-1>结构体定义<a hidden class=anchor aria-hidden=true href=#结构体定义-1>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>LNode</span> <span class=o>*</span><span class=n>PtrToLNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>LNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ElementType</span> <span class=n>Data</span><span class=p>;</span>       <span class=c1>//数据元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PtrToLNode</span> <span class=n>Next</span><span class=p>;</span>        <span class=c1>//指向后继的指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToLNode</span> <span class=n>Position</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PtrToLNode</span> <span class=n>List</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=求表长度>求表长度<a hidden class=anchor aria-hidden=true href=#求表长度>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>Length</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>p</span><span class=o>=</span><span class=n>L</span><span class=p>;</span>       <span class=c1>//p指向链表头结点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>p</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>=</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>j</span><span class=p>;</span>        <span class=c1>//当前p指向第j个结点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>时间性能为O(n)。</p><h5 id=查找-1>查找<a hidden class=anchor aria-hidden=true href=#查找-1>#</a></h5><p>查找分为两种情况，一种是按序号查找，一种是按值查找。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>Position</span> <span class=nf>FindKth</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=kt>int</span> <span class=n>K</span><span class=p>){</span>    <span class=c1>//按序号查找，找第K个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Position</span> <span class=n>p</span><span class=o>=</span><span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>Next</span><span class=o>&amp;&amp;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>K</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>=</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>==</span><span class=n>K</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>p</span><span class=p>;</span>       <span class=c1>//找到第K个，返回指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>        <span class=c1>//未找到
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Position</span> <span class=nf>Find</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>){</span>   <span class=c1>//按值查找，找元素X的位置
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Positon</span> <span class=n>p</span><span class=o>=</span><span class=n>L</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>p</span><span class=o>&amp;&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>Data</span><span class=o>!=</span><span class=n>X</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>=</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>Next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>查找的平均时间性能为O(n)。</p><h5 id=插入-1>插入<a hidden class=anchor aria-hidden=true href=#插入-1>#</a></h5><p>要在结点P之前插入新结点，先构造一个新结点，再找到P之前的结点，然后修改指针，插入新结点。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Insert</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=n>ElementType</span> <span class=n>X</span><span class=p>,</span> <span class=n>Position</span> <span class=n>P</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>tmp</span><span class=p>,</span> <span class=n>pre</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>pre</span><span class=o>=</span><span class=n>L</span><span class=p>;</span> <span class=n>pre</span><span class=o>&amp;&amp;</span><span class=n>pre</span><span class=o>-&gt;</span><span class=n>Next</span><span class=o>!=</span><span class=n>P</span><span class=p>;</span> <span class=n>pre</span><span class=o>=</span><span class=n>pre</span><span class=o>-&gt;</span><span class=n>Next</span><span class=p>)</span>    <span class=c1>//找到P的前一个结点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pre</span><span class=o>==</span><span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;插入位置参数错误</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span><span class=o>=</span><span class=p>(</span><span class=n>Position</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>LNode</span><span class=p>));</span>     <span class=c1>//分配内存，构造结点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>tmp</span><span class=o>-&gt;</span><span class=n>Data</span><span class=o>=</span><span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span><span class=o>-&gt;</span><span class=n>Next</span><span class=o>=</span><span class=n>P</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pre</span><span class=o>-&gt;</span><span class=n>Next</span><span class=o>=</span><span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>平均查找次数为n/2，平均时间性能为O(n)。</p><h5 id=删除-1>删除<a hidden class=anchor aria-hidden=true href=#删除-1>#</a></h5><p>要删除结点P，先找到P之前的结点，然后修改指针，最后释放内存空间。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Delete</span><span class=p>(</span><span class=n>List</span> <span class=n>L</span><span class=p>,</span> <span class=n>Position</span> <span class=n>P</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>Position</span> <span class=n>tmp</span><span class=p>,</span> <span class=n>pre</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>pre</span><span class=o>=</span><span class=n>L</span><span class=p>;</span> <span class=n>pre</span><span class=o>&amp;&amp;</span><span class=n>pre</span><span class=o>-&gt;</span><span class=n>Next</span><span class=o>!=</span><span class=n>P</span><span class=p>;</span> <span class=n>pre</span><span class=o>=</span><span class=n>pre</span><span class=o>-&gt;</span><span class=n>Next</span><span class=p>)</span>    <span class=c1>//找到P的前一个结点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pre</span><span class=o>==</span><span class=nb>NULL</span><span class=o>||</span><span class=n>P</span><span class=o>==</span><span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;删除位置参数错误</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp</span><span class=o>=</span><span class=n>P</span>
</span></span><span class=line><span class=cl>        <span class=n>pre</span><span class=o>-&gt;</span><span class=n>Next</span><span class=o>=</span><span class=n>tmp</span><span class=o>-&gt;</span><span class=n>Next</span><span class=p>;</span>    <span class=c1>//删除P
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>free</span><span class=p>(</span><span class=n>tmp</span><span class=p>);</span>      <span class=c1>//释放空间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>平均查找次数为n/2，平均时间性能为O(n)。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://h-jch.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></li></ul><nav class=paginav><a class=prev href=https://h-jch.github.io/posts/code/stack/><span class=title>« Prev</span><br><span>栈</span></a>
<a class=next href=https://h-jch.github.io/posts/code/cpp-const/><span class=title>Next »</span><br><span>C++ const关键字</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://h-jch.github.io>Kei's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>